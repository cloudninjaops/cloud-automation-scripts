import "tfplan/v2" as tfplan
import "types"
import "strings"

# =========================
# CONFIG (edit as needed)
# =========================

# Allowed AWS service principals that can invoke Lambda
allowed_service_principals = {
  "events.amazonaws.com": true,
  "sns.amazonaws.com": true,
  "s3.amazonaws.com": true,
  "logs.amazonaws.com": true,
  "apigateway.amazonaws.com": true,
  "cloudwatch.amazonaws.com": true,
  "states.amazonaws.com": true,
}

# Allow specific external AWS account IDs (optional)
allowed_external_accounts = {
  # "123456789012": true,
}

# =========================
# Helpers
# =========================
func is_null(v)   { return types.type_of(v) is "null" }
func is_map(v)    { return types.type_of(v) is "map" }
func is_string(v) { return types.type_of(v) is "string" }

func mget(m, k) {
  if !is_map(m) { return null }
  if m contains k { return m[k] }
  return null
}

func lower(v) {
  if is_string(v) { return strings.lower(v) }
  return ""
}

func is_allowed_service(principal) {
  p = lower(principal)
  return allowed_service_principals[p] else false
}

# Parse account id from ARN without regex:
# arn:aws:iam::123456789012:role/RoleName
func extract_account_id_from_arn(arn) {
  if !is_string(arn) { return "" }
  if !strings.has_prefix(arn, "arn:") { return "" }

  parts = strings.split(arn, ":")
  if length(parts) < 6 { return "" }

  acct = parts[4]
  if !is_string(acct) { return "" }
  return acct
}

func is_iam_arn(principal) {
  if !is_string(principal) { return false }
  return strings.has_prefix(principal, "arn:aws:iam::")
}

# =========================
# Policy logic
# =========================
violations = []

perms = tfplan.resource_changes["aws_lambda_permission"] else {}

for perms as addr, rc {
  after = rc.change.after else null
  if is_null(after) { continue }

  principal = mget(after, "principal")
  if !is_string(principal) or principal == "" { continue }

  # 1) Wildcard is always denied
  if principal == "*" {
    violations = append(violations, addr + " uses wildcard principal (*)")
    continue
  }

  # 2) AWS service principals: allow only from allowlist
  if strings.contains(principal, ".amazonaws.com") {
    if !is_allowed_service(principal) {
      violations = append(violations, addr + " uses unapproved service principal: " + principal)
    }
    continue
  }

  # 3) IAM principals (ARNs): deny unless allowlisted by account ID
  if is_iam_arn(principal) {
    acct = extract_account_id_from_arn(principal)
    if acct != "" and (allowed_external_accounts[acct] else false) {
      continue
    }
    violations = append(violations, addr + " allows IAM principal ARN (potential cross-account): " + principal)
    continue
  }

  # 4) Anything else: deny (unknown principal format)
  violations = append(violations, addr + " uses unsupported/unknown principal format: " + principal)
}

main = rule { length(violations) is 0 }
