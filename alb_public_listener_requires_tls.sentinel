# ======================================================================
# Policy: deny-public-lb-without-tls.sentinel
# Purpose:
#   Block public (internet-facing) ALB/NLB listeners that do not use TLS/SSL.
#
# Covers:
#   - aws_lb (ALB/NLB) scheme == "internet-facing"
#   - aws_lb_listener protocol:
#       * ALB: must be HTTPS (HTTP allowed only if redirect-to-HTTPS)
#       * NLB: must be TLS
#
# Notes:
#   - Written defensively to avoid runtime errors on null/unknown attrs.
#   - Uses tfplan/v2 to evaluate planned resources.
# ======================================================================

import "tfplan/v2" as tfplan
import "types"
import "strings"

# -------------------------
# Helpers (defensive access)
# -------------------------

func is_null(v) {
  return types.type_of(v) is "null"
}

func is_string(v) {
  return types.type_of(v) is "string"
}

func is_map(v) {
  return types.type_of(v) is "map"
}

func is_list(v) {
  return types.type_of(v) is "list"
}

# Safe get for map attributes: returns null if missing/not a map
func mget(m, k) {
  if !is_map(m) { return null }
  if m contains k { return m[k] }
  return null
}

# Uppercase string safely
func up(v) {
  if is_string(v) { return strings.upper(v) }
  return ""
}

# -------------------------
# Collect relevant resources
# -------------------------

lbs      = tfplan.resource_changes["aws_lb"] else {}
listeners = tfplan.resource_changes["aws_lb_listener"] else {}

# Map lb_arn -> { scheme, lb_type }
lb_by_arn = {}

# Build lb_by_arn from planned LBs
# Handles create/update where after exists
for lbs as lb_addr, lb_rc {
  after = lb_rc.change.after else null
  if is_null(after) { continue }

  arn    = mget(after, "arn")
  scheme = mget(after, "scheme")
  lbt    = mget(after, "load_balancer_type")

  if is_string(arn) && arn != "" {
    lb_by_arn[arn] = {
      "scheme": scheme,
      "type":   lbt,
      "addr":   lb_addr,
    }
  }
}

func is_public_lb(listener_after) {
  lb_arn = mget(listener_after, "load_balancer_arn")
  if !is_string(lb_arn) || lb_arn == "" { return false }

  lb = mget(lb_by_arn, lb_arn)
  if is_null(lb) { return false }

  scheme = mget(lb, "scheme")
  return is_string(scheme) && strings.lower(scheme) == "internet-facing"
}

func lb_type_for(listener_after) {
  lb_arn = mget(listener_after, "load_balancer_arn")
  lb = mget(lb_by_arn, lb_arn)
  if is_null(lb) { return "" }

  t = mget(lb, "type")
  if is_string(t) { return strings.lower(t) }
  return ""
}

# -------------------------
# Listener checks
# -------------------------

func listener_protocol(listener_after) {
  p = mget(listener_after, "protocol")
  return up(p)
}

func is_secure_listener(listener_after) {
  p = listener_protocol(listener_after)
  return p == "HTTPS" || p == "TLS"
}

# Allow ALB HTTP listener only if default_action is a redirect to HTTPS
func is_http_redirect_to_https(listener_after) {
  p = listener_protocol(listener_after)
  if p != "HTTP" { return false }

  acts = mget(listener_after, "default_action")
  if !is_list(acts) { return false }

  # If any action is redirect with protocol HTTPS => allow
  for acts as a {
    if !is_map(a) { continue }
    at = up(mget(a, "type"))
    if at != "REDIRECT" { continue }

    redir = mget(a, "redirect")
    if !is_map(redir) { continue }

    rproto = up(mget(redir, "protocol"))
    if rproto == "HTTPS" {
      return true
    }
  }

  return false
}

# Core rule: internet-facing requires TLS/SSL
violations = []

for listeners as l_addr, l_rc {
  after = l_rc.change.after else null
  if is_null(after) { continue }

  if !is_public_lb(after) { continue }

  lbt = lb_type_for(after)         # "application" or "network"
  p   = listener_protocol(after)   # "HTTP"/"HTTPS"/"TCP"/"TLS"/...

  # ALB rules
  if lbt == "application" {
    # HTTPS required; allow HTTP only if it redirects to HTTPS
    if p == "HTTP" && is_http_redirect_to_https(after) {
      continue
    }
    if p != "HTTPS" {
      violations = append(violations, {
        "listener": l_addr,
        "lb_type":  "alb",
        "protocol": p,
        "reason":   "Public ALB listener must be HTTPS (HTTP allowed only with redirect-to-HTTPS).",
      })
    }
    continue
  }

  # NLB rules
  if lbt == "network" {
    # TLS required
    if p != "TLS" {
      violations = append(violations, {
        "listener": l_addr,
        "lb_type":  "nlb",
        "protocol": p,
        "reason":   "Public NLB listener must be TLS.",
      })
    }
    continue
  }

  # If type is unknown, be conservative: require TLS/HTTPS
  if !is_secure_listener(after) {
    violations = append(violations, {
      "listener": l_addr,
      "lb_type":  "unknown",
      "protocol": p,
      "reason":   "Public LB listener must use TLS/SSL (HTTPS/TLS).",
    })
  }
}

main = rule {
  length(violations) is 0
}
