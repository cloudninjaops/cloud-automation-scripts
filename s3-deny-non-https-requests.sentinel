# s3_require_https_only.sentinel
# Enforce HTTPS-only access for every aws_s3_bucket in the plan.
# Safe-fail: unknown / missing / unparsable => violation.

import "tfplan/v2" as tfplan
import "json"

violations = []

# ---------------------------------------------------------------------------
# Helper: verify that policy document contains Deny for aws:SecureTransport=false
# ---------------------------------------------------------------------------
has_https_enforcement = func(policy_doc) {
    if type(policy_doc) is not "map" or policy_doc.Statement is undefined {
        return false
    }

    statements = policy_doc.Statement
    if type(statements) is "map" {
        statements = [statements]
    }

    return any statements as _, st {
        st.Effect is "Deny" and
        st.Condition is not null and
        type(st.Condition) is "map" and (
            (
                st.Condition.Bool is not null and
                type(st.Condition.Bool) is "map" and
                (
                    st.Condition.Bool["aws:SecureTransport"] is "false" or
                    st.Condition.Bool["aws:SecureTransport"] is false
                )
            ) or (
                st.Condition.BoolIfExists is not null and
                type(st.Condition.BoolIfExists) is "map" and
                (
                    st.Condition.BoolIfExists["aws:SecureTransport"] is "false" or
                    st.Condition.BoolIfExists["aws:SecureTransport"] is false
                )
            )
        )
    }
}

# ---------------------------------------------------------------------------
# Collect and evaluate S3 bucket policies
# ---------------------------------------------------------------------------
resource_changes = tfplan.resource_changes else []

buckets = filter resource_changes as _, rc {
    rc.type is "aws_s3_bucket" and
    rc.change.after is not null and
    rc.change.after.bucket is not null
} else []

if buckets is undefined {
    append(violations, "tfplan.resource_changes undefined")
}

for buckets as _, b {
    bucket_name = b.change.after.bucket

    policies = filter resource_changes as _, rc {
        rc.type is "aws_s3_bucket_policy" and
        rc.change.after is not null and
        rc.change.after.bucket is bucket_name
    } else []

    if length(policies) == 0 {
        append(violations, sprintf("%s: missing bucket policy", b.address))
        continue
    }

    policy_str = policies[0].change.after.policy
    if policy_str is null {
        append(violations, sprintf("%s: bucket policy is null", b.address))
        continue
    }

    policy_doc = null
    valid_parse = true
    try {
        policy_doc = json.unmarshal(policy_str)
    } catch {
        valid_parse = false
    }

    if not valid_parse {
        append(violations, sprintf("%s: invalid JSON policy", b.address))
        continue
    }

    if not has_https_enforcement(policy_doc) {
        append(violations, sprintf("%s: missing aws:SecureTransport deny rule", b.address))
    }
}

# ---------------------------------------------------------------------------
# Decision and output
# ---------------------------------------------------------------------------
main = rule { length(violations) == 0 }

if length(violations) > 0 {
    print("S3 HTTPS enforcement violations (safe-fail):", violations)
}
