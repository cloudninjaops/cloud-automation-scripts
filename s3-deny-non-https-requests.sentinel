import "tfplan/v2" as tfplan
import "json" as json
import "types" as types
import "strings" as strings

# Define a collection of all S3 bucket policies in the plan that are being created or updated
s3_bucket_policies = filter tfplan.resource_changes as _, rc {
  rc.type is "aws_s3_bucket_policy" and
  (rc.change.actions contains "create" or rc.change.actions contains "update")
}

# Find all policies that *do not* enforce HTTPS
violating_policies = []
for s3_bucket_policies as p[] {
  # Safely handle cases where the policy attribute might be undefined (e.g., during a destroy or computed)
  if types.type_of(p.change.after.policy) is "undefined" {
    continue
  }

  policy_doc = json.unmarshal(p.change.after.policy)

  # Policies must contain at least one statement
  if length(policy_doc.Statement else []) is 0 {
    append(violating_policies, p.address)
    continue
  }

  # Assume a violation exists until a valid "deny" statement is found
  has_secure_transport_deny = false

  # Check if a Deny statement with the SecureTransport condition exists
  for policy_doc.Statement as statement {
    # Safely check for the "deny" attribute using "else"
    if (statement.Effect else "") is "Deny" and
       ((statement.Condition else {}).Bool["aws:SecureTransport"] else null) is "false" {
      has_secure_transport_deny = true
      break
    }
  }

  # If no such statement is found, it's a violation
  if not has_secure_transport_deny {
    append(violating_policies, p.address)
  }
}

# The main rule fails if any violating policies were found
main = rule {
  length(violating_policies) is 0
} {
  "The following S3 bucket policies do not enforce SSL/HTTPS requests: #{strings.join(violating_policies, ', ')}"
}
