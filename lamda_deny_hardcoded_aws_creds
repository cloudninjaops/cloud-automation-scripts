import "tfplan/v2" as tfplan
import "types"
import "strings"

# Keys to block if present in Lambda environment variables
blocked_env_keys = {
  "AWS_ACCESS_KEY_ID": true,
  "AWS_SECRET_ACCESS_KEY": true,
  "AWS_SESSION_TOKEN": true,
}

# -------------------------
# Helpers (defensive access)
# -------------------------
func is_null(v)   { return types.type_of(v) is "null" }
func is_map(v)    { return types.type_of(v) is "map" }
func is_string(v) { return types.type_of(v) is "string" }

func mget(m, k) {
  if !is_map(m) { return null }
  if m contains k { return m[k] }
  return null
}

func up(v) {
  if is_string(v) { return strings.upper(v) }
  return ""
}

func is_nonempty_string(v) {
  return is_string(v) and strings.trim(v, " \t\r\n") != ""
}

# -------------------------
# Policy logic
# -------------------------
violations = []

funcs = tfplan.resource_changes["aws_lambda_function"] else {}

for funcs as addr, rc {
  after = rc.change.after else null
  if is_null(after) { continue }

  env = mget(after, "environment")
  if is_null(env) { continue }

  vars = mget(env, "variables")
  if !is_map(vars) { continue }

  # Iterate over all environment variables and check blocked keys
  for vars as k, v {
    key = up(k)

    if blocked_env_keys[key] else false {
      # If value is any non-empty string -> violation
      if is_nonempty_string(v) {
        violations = append(violations, addr + " sets forbidden env var " + key + " with a non-empty value")
      }
    }
  }
}

main = rule { length(violations) is 0 }
